/*
 * *** Maja Swiderska  ***
 *
 * This HashingProblems object contains three methods / problems that you must
 * complete utilize the HashMap object within the Java's Collection Framework Library.
 *
 * The three methods / problems you need to solve are:
 *  - getAverage
 *  - odd
 *  - twoSums
 */

import java.util.HashMap;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;

class HashingProblems {

    /*
     * Method getAverage()
     *
     * This method accepts two parameters. The first is a HashMap object, while the second
     * is an array of integers. This method must compute the average of the values for each
     * 'key' that is found in BOTH the HashMap and the array.
     *
     * For example, if only the keys 1 and 2 from the array are present in the HashMap, and
     * lets say their values were 10 and 20, respectively, then the average is calculated
     * as (10+20)/2 = 15. Lets also say the keys â€˜7â€™ and â€˜8â€™ are in the array, but those keys
     * are not present in the HashMap. That means their corresponding values in the HashMap
     * are not included in the average calculation.
     */

    public double getAverage(HashMap<Integer, Integer> map, int[] array) {

        int sum = 0; //This will hold the total of all matching values
        int count = 0; //This will count how many matches that is found

        //looking at each number in the array, looping through each position in the array
        for (int i = 0; i < array.length; i++) {
            //getting the number at the current array position
            int currentNumber = array[i];
            //Checking if this number is a key in the map
            if (map.containsKey(currentNumber)) {
                //getting the value that is associated with this key
                int value = map.get(currentNumber);
                //If yes, then add its value to the sum, also this adds to the running total
                sum += map.get(currentNumber);
                count++;
            }
        }
        //calculating the average
        if (count == 0) {
            //no matches so it should return 'not a number'
            //reason it doesn't match because can't divide by zero
            return 0.0 / 0.0;
        }
        //Calculating the average -> total sum / number of items
        return (double) sum / count;
    }


    /*
     * Method odd()
     *
     * This method accepts a HashMap object, and returns an ArrayList object with the
     * values of the corresponding keys that are odd.
     */

    public ArrayList<String> odd(HashMap<Integer, String> map) {
        //Creating an empty list to store the results
        ArrayList<String> result = new ArrayList<>();

        //getting all of the keys from the HashMap as a Set
        Set<Integer> keys = map.keySet();

        //Converting the Set to an Array
        Integer[] keysArray = keys.toArray(new Integer[0]);

        //loping through each key in the array
        for(int i = 0; i < keysArray.length; i++) {
            //getting the current key
            Integer currentKey = keysArray[i];

            //Checking if the key is an odd, basically it's not divisible by 2
            if(currentKey % 2 == 1) {
                //the key is odd, so i'm getting the value from the HashMap
                String value = map.get(currentKey);
                //adding this value to the result list
                result.add(value);
            }
        }
        //returning the completed list of values from the odd keys
        return result;
    }


    /*
     * Method twoSums()
     *
     * You ARE to solve this problem in time complexity O(n). The submittals will be spot checked.
     *
     * Problem statement:
     * Suppose you are given an integer array containing the values [1,4,5,7,8,9] along with the
     * value k=4, where k is the difference between two array elements. How many times does k appear
     * in that list?
     *
     * With the above numbers, it will be three times:
     *    k = 4
     *    (5 - 1) = k
     *    (8 - 4) = k
     *    (9 - 5) = k
     *    k appears 3 times.
     *
     * All combinations must be considered. But, any other combination of the numbers in the array
     * results in a difference value that is not equal to k (k=4 in this case).
     *
     * This can be solved using nested for-loops, checking all combinations of the values in the array.
     * But the time complexity would be O(n^2).
     *
     * In order to solve this problem in O(n) complexity, utilize a HashMap (or a HashSet).
     *
     * You are two solve this using a HashMap (or you can use a HashSet, which is implemented
     * using HashMap). To solve this, you should populate the HashMap (or HashSet) based on
     * the array (this will be complexity time on the order of 'n'). After populating the HashMap,
     * consider a for-loop that does a lookup (probe) of the HashMap (or HashSet) on each iteration
     * of the loop. This will also have a complexity on the order of 'n', as the hashing probes are a
     * constant time complexity (after removing any constant based on collisions).
     *
     * This will result in a time complexity of O(n) for the overall method.
     *
     * NOTE: Solving using a HashMap or HashSet is fine (either is okay). HashSet may be easier to code?
     */

    public int twoSums(int[] numbers, int k) {
        //Setting up the counter for valid pairs
        int count = 0;

        //Putting all the numbers in a set for fast lookups
        //HashSet gives me O(1) lookups which is superfast and I can quickly check if a number does exist
        HashSet<Integer> numSet = new HashSet<>();
        //Adding all of the numbers to the HashSet
        for(int i = 0; i < numbers.length; i++) {
            //getting the current number from the array
            int currentNumber = numbers[i];
            //adding it to the HashSet
            numSet.add(currentNumber);
        }
        //Checking if this needed number exists in the HashSet
        for(int i = 0; i < numbers.length; i++) {
            //getting the current number that i'm checking
            int currentNumber = numbers[i];
            //calculating what number would make a good pair with k
            int neededNumber = currentNumber + k;

            //Checking if this needed number exists in the set
            if(numSet.contains(neededNumber)) {
                //It does, I found a valid pair
                count = count + 1;
            }
        }
        //return the total number of valid pairs found
        return count;
    }
}

// I only commented on the work that I've done, so you can understand what I was thinking and what each function does
