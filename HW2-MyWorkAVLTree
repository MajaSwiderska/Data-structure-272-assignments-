/*
 * *** Maja Swiderska ***
 *
 * This file implements a simple AVL Tree focused only on INSERTIONS.
 * You are to implement the four rotation methods so that insertions
 * keep the tree balanced. No deletion of nodes is required in this assignment.
 *
 * Notes to students:
 *  - We use heightOf(null) = -1 and height(leaf) = 0.
 *  - Duplicates are ignored (do nothing).
 *  - The preorderTraversal() returns values separated by a single space,
 *    and ends with a space (e.g., "20 10 30 ").
 */

class Node {
    int value;
    int height;
    Node leftChild, rightChild;

    public Node(int data) {
        value = data;
        height = 0;
        leftChild = rightChild = null;
    }
}

public class LUC_AVLTree {
    private Node rootNode;

    public LUC_AVLTree() {
        rootNode = null;
    }

    public void removeAll() {
        rootNode = null;
    }

    public boolean checkEmpty() {
        return rootNode == null;
    }

    public void insert(int v) {
        rootNode = insertElement(v, rootNode);
    }

    public String preorderTraversal() {
        return preorderTraversal(rootNode);
    }

    // ----- Helpers we need for insertion/height/balance -----
    private int getHeight(Node n) {
        return (n == null) ? -1 : n.height;
    }

    private int getMax(int a, int b) {
        return (a > b) ? a : b;
    }

    private int getBalanceFactor(Node n) {
        if (n == null) return 0;
        int lh = getHeight(n.leftChild) + 1;
        int rh = getHeight(n.rightChild) + 1;
        return lh - rh; // balanced if in {-1,0,1}
    }

    private String preorderTraversal(Node n) {
        if (n == null) return "";
        return n.value + " " + preorderTraversal(n.leftChild) + preorderTraversal(n.rightChild);
    }

    // ----- Insert with rebalancing (calls your rotations) -----
    private Node insertElement(int value, Node node) {
        if (node == null) return new Node(value);

        if (value < node.value) {
            node.leftChild = insertElement(value, node.leftChild);
            int bf = getBalanceFactor(node);
            if (Math.abs(bf) > 1) {
                // Left heavy: choose LL or LR based on where we inserted
                if (value < node.leftChild.value) {
                    node = LLRotation(node);   // TODO: you implement
                } else {
                    node = LRRotation(node);   // TODO: you implement
                }
            }
        } else if (value > node.value) {
            node.rightChild = insertElement(value, node.rightChild);
            int bf = getBalanceFactor(node);
            if (Math.abs(bf) > 1) {
                // Right heavy: choose RR or RL based on where we inserted
                if (value > node.rightChild.value) {
                    node = RRRotation(node);   // TODO: you implement
                } else {
                    node = RLRotation(node);   // TODO: you implement
                }
            }
        } else {
            // duplicate -> do nothing
        }

        // update height on the way back up
        node.height = getMax(getHeight(node.leftChild), getHeight(node.rightChild)) + 1;
        return node;
    }

    /***********************************************************
     * YOUR WORK STARTS HERE
     * Implement the four rotations below. Keep them small and neat.
     * After rotation, update the heights of the nodes you moved.
     ***********************************************************/

    /**
     * LLRotation: Right-rotate around X when left-left heavy.
     * Return the new subtree root.
     */
    private Node LLRotation(Node x) {
        // TODO: implement, then UPDATE heights, then return new root

        //First I need to identify the new root meaning the left child of x becomes the new root
        Node newRoot = x.leftChild;

        //Move the newRoot's right child to become x's left child
        x.leftChild = newRoot.rightChild;
        //Make x the right child of newRoot
        newRoot.rightChild = x;

        //I'm updating the height, I'm updating x's height based on its new children
        x.height = getMax(getHeight(x.leftChild), getHeight(x.rightChild)) + 1;
        //I'm also updating the newRoot's height based on its children and that also includes the updated x
        newRoot.height = getMax(getHeight(newRoot.leftChild), getHeight(newRoot.rightChild)) + 1;

        //I'm returning the new root of this specific subtree
        return newRoot; // placeholder so code compiles
    }

    /**
     * RRRotation: Left-rotate around X when right-right heavy.
     * Return the new subtree root.
     */

    /**
     * The way how I visualize this:
     *
     * Before:
     * x
     *  \
     *   y
     *    \
     *     z
     *
     * After the RRRotation:
     *     y
     *    / \
     *   x   z
     */
    private Node RRRotation(Node x) {
        // TODO: implement, then UPDATE heights, then return new root

        //I'm identifying the new root meaning the right child of x becomes the new root
        Node newRoot = x.rightChild;

        //I'm moving the newRoot's left child to become x's right child
        x.rightChild = newRoot.leftChild;
        //Making x the left child of newRoot
        newRoot.leftChild = x;

        //I'm also updating x's height based on its new children
        x.height = getMax(getHeight(x.leftChild), getHeight(x.rightChild)) + 1;
        //Also updating the newRoot's height based on its children and that includes the updated x
        newRoot.height = getMax(getHeight(newRoot.leftChild), getHeight(newRoot.rightChild)) + 1;

        //Returning the new root of this specific subtree
        return newRoot;
    }

    /**
     * LRRotation: First rotate left child to the left, then rotate X to the right.
     * Return the new subtree root.
     */
    /**
     * This is how I visualize this:
     * Before:
     *      x
     *     /
     *    y
     *     \
     *      z
     * After the LRRotation:
     *      z
     *     / \
     *    y   x
     *
     */
    private Node LRRotation(Node x) {
        // TODO: implement using your other rotations (small and clean)

            //I need to convert to LL case
            //So I do RR rotation on x's left child to make it left-heavy
            //This just moves the problem node up to become left child of x
            x.leftChild = RRRotation(x.leftChild);
            // I'm doing the LL rotation on x to balance the tree
            return LLRotation(x);
        }
        /**
         * RLRotation: First rotate right child to the right, then rotate X to the left.
         * Return the new subtree root.
         */
    /**
     * This is how I visualize this:
     * Before:
     * x
     *  \
     *   y
     *  /
     * z
     * After the RLRotation:
     *    z
     *   / \
     *  x   y
     *
     */
    private Node RLRotation (Node x){
            // TODO: implement using your other rotations (small and clean)

            //I need to convert to RR case
            //So I do the LL rotation on x's right child to make it right-heavy
            //This just moves the problem node up to become the right child of x
            x.rightChild = LLRotation(x.rightChild);
            //I'm doing the RR rotation on x to balance the tree
            return RRRotation(x);
        }
    }
