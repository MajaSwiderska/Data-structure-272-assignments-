import java.util.*;

public class HW1 {

    /* =========================
     * Part 1 â€” Linked List (SLL)
     * ========================= */
    public static class SinglyLinkedList {
        static class Node {
            int data;
            Node next;
            Node(int d){ data = d; }
        }

        private Node head;
        private int size = 0;

        // Utilities for testing/demo
        public void addLast(int x){
            Node nn = new Node(x);
            if(head == null){ head = nn; }
            else{
                Node cur = head;
                while(cur.next != null) cur = cur.next;
                cur.next = nn;
            }
            size++;
        }

        public int size() { return size; }

        @Override public String toString(){
            StringBuilder sb = new StringBuilder("[");
            Node cur = head;
            while(cur != null){
                sb.append(cur.data);
                cur = cur.next;
                if(cur != null) sb.append(", ");
            }
            sb.append("]");
            return sb.toString();
        }
        /**
         * Remove all duplicate values, preserving the first occurrence.
         * Example: [3,1,3,2,1] -> [3,1,2]
         */
        public void removeDuplicates(){
            // TODO: implement using a HashSet or O(n^2) two-pointer approach
            //Doing set to have track on the values that I seen
            Set<Integer> seen = new HashSet<>(); //The hashset does give me O(1) lookup times for checking duplicates
            Node current = head; //current node that I'm checking
            Node prev = null; // Prev node (it just helps me to remove any duplicates)

            while(current != null) {
                if(seen.contains(current.data)) {
                 //dup found so skipping the current node / removing the duplicate
                 prev.next = current.next; //This just skips over the duplicate node
                 size--; //decreasing the node in list
                } else {
                    //New value so I will add to set and move the prev up (forward)
                    seen.add(current.data); //This just adds it to the 'seen' set to remember later
                    prev = current; //this is the new prev node
                }
                current = current.next; //moving to the next node
            }

        }


        /**
         * Reverse the entire list by using a stack (java.util.Stack).
         * You must use a Stack in your solution (push values or nodes).
         * Example: [1,2,3,4] -> [4,3,2,1]
         * Time: O(n), Extra Space: O(n).
         */
        public void reverse(){
            // TODO: implement using java.util.Stack
            if(head == null) return; //there is nothing to reverse
            Stack<Node> stack = new Stack<>(); //using stack to help reverse the order

            //First thing I need to do is to push all the nodes into the stack or to make it more simple (the last node will be on top)
            Node current = head;
            while(current != null) {
                stack.push(current); //putting node on stack
                current = current.next; //moving to the next node
            }
            //Next step is to pop from the stack and try to rebuild the list
            head = stack.pop(); //The last node is now the first node
            current = head; //starting to build from the new first node
            //will continue popping until the stack is empty
            while (!stack.isEmpty()) {
                current.next = stack.pop(); //It's going to point to the next reversed node
                current = current.next; //moving to the next node
            }
            current.next = null; // end of list so that means the last node should point to nothing

        }

        /**
         * Return the value of the n-th node from the end (1-based).
         * Example: [10,20,30,40,50], n=2 -> 40.
         * Use a single pass (two pointers). Throw NoSuchElementException if invalid.
         */
        public int getNthFromEnd(int n){
            // TODO: implement two-pointer technique
            if (n <= 0) {
                throw new NoSuchElementException("n must be at least 1");
            }
            Node fast = head; //fast pointer that will move forward
            Node slow = head; //slow pointer that will be behind

            //move the fast pointer n steps forward/ahead and this will create a gap of n nodes between fast and slow pointers
            for(int i = 0; i < n; i++) {
                if(fast == null) {
                    throw new NoSuchElementException("The list is short"); //not enough nodes
                }
                fast = fast.next; //advance the fast pointer
            }
            //Moving both of the pointers until fast reaches end and the slow pointer will be n steps behind the fast pointer
            while(fast != null) {
                fast = fast.next; //moving fast-forward
                slow = slow.next; //moving slow forward
            }
            return slow.data; //The slow pointer is now at the nth position from the end

        }

    }

    /* =========================
     * Part 2 â€” Stack
     * ========================= */

    /**
     * STACK: Return true if input is a palindrome ignoring case and spaces.
     * Examples: "Race Car" -> true, "racecar" -> true, "ab ca" -> false.
     * Time: O(n), Extra Space: O(n).
     * Use java.util.Stack<Character>.
     */
    public static boolean isPalindrome(String input) {
        // TODO: implement method here
        //make the lowercase abd remove spaces
        String s = input.toLowerCase().replaceAll("\\s+", "");
        Stack<Character> stack = new Stack<>(); //Stack to reverse the letters

        // Push all characters onto the stack so it can come out in reverse order
        for (int i = 0; i < s.length(); i++) {
            stack.push(s.charAt(i)); //pushing each character into the stack
        }

        // Compare characters from start with popped characters from stack
        for (int i = 0; i < s.length(); i++) {
            //pop from the stack can give characters in reverse order, and it compares with original string characters in a forward order
            if (s.charAt(i) != stack.pop()) {
                return false; //the letters don't match so it's not palindrome
            }
        }

        return true; //all the letters match so it's palindrome
    }

    /* =========================
     * Part 3 â€” Algorithm Analysis
     * ========================= */

    public static int algorithmAnalysis1(int n, int m) {
        int a = 0, b = 0;

        for (int i=0; i < n; i++) a++;   // this loops runs n time
        for (int j=0; j < m; j++) b++;   // loops runs m times

        /*
         * Select the correct option listed below:
         *   1. O(N * M) time, O(1) space
         *   2. O(N + M) time, O(N + M) space
         *   3. O(N + M) time, O(1) space
         *   4. O(N * M) time, O(N + M) space
         *
         * TODO: return the answer (which option is correct), in the return statement
         */

        // RETURN THE CORRECT OPTION NUMBER LISTED ABOVE
        // n + m steps = O(n+m) --> times
        // only uses 4 numbers (a,b,i,j) so O(1) constant space --> space
        // that's why 3 is correct
        return 3;
    }


    public static int algorithmAnalysis2(int n) {
        int i, j, k = 0;
        for (i = n/2; i <= n; i++) //outer loop = about n/2 times -> O(n)
            for ( j = 2; j <= n; j = j*2 ) //Inner loop = j doubles until n -> O(long n)
                k += n/2;

        /*
         * Select the correct option listed below:
         *   1. O(N) time
         *   2. O(N log N) time
         *   3. O(N^2) time
         *   4. O(N^2 log N) time
         *
         * TODO: return the answer (which option is correct), in the return statement
         */

        // RETURN THE CORRECT OPTION LISTED ABOVE
        //Total time -> O(n) * O(long n) = 0(n log n)
        return 2;
    }
}
